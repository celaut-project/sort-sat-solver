syntax = "proto3";
import "google/protobuf/descriptor.proto";
package ipss;

//  -----------------------
//  SERVICE SPECIFICATION.
//  -----------------------
// Hash Table ( IPDL ?)
message Hash {
    string hash = 1;
    repeated string tag = 2;
    // Mesh specification can be applied. <- must be optional
}

// API: Defines how you can interact with the service, the ports where it listens, the communication protocols that it supports, methods and the different errors and responses that it can give.
message ProtocolMesh {
    repeated string tag = 1;
    // Mesh specification can be applied. <- must be optional
}

message Slot {
    int32 port = 1;
    ProtocolMesh transport_protocol = 2;
    google.protobuf.FileDescriptorSet aplication_protocol = 3;
    // Cost function can be applied. <- must be optional
}

// Container: Specifies the container where the service runs, microarchitecture, entry point and filesystem (DAG?), and environment variables.
message Architecture {
    repeated string tag = 1;
    // Architecture specification can be applied. <- must be optional.
}

message Container {
    Architecture architecture = 1;
    repeated Hash filesystem = 2;
    repeated string enviroment_variables = 3;
    string entrypoint = 4;
}

// Tensor: Defines the “intelligence” that the service can provide, I think it would be a description of a polynomial (without coefficients and describing the variables).
message Tensor {
    message Variable {
        string id = 1;
        repeated string tag = 2;
        optional google.protobuf.DescriptorProto field = 3;
    }
    repeated Variable output_variable = 1;
    repeated Variable input_variable = 2;
}

// Ledger: Defines the database that the service can provide.
message Ledger {
    repeated string tag = 1;
    // Ledger specification can be applied. <- must be optional
    //  it would be a class diagram and a consensus algorithm.
}

message Service {
    google.protobuf.FileDescriptorSet syntax = 1;
    Container container = 2;
    repeated Slot api = 3;
    Tensor tensor = 4;
    Ledger ledger = 5;
}

//  ------------------------
//  INSTANCE SPECIFICATION.
//  ------------------------
// Used for specify node peers, node-host instancies, ledger-nodes instancies and tensor instancies.
message Instance {
    String ip = 1;
    repeated Slot api = 2;
}

//  -------------------------------
//  SERVICE INITIAL CONFIGURATION.
//  -------------------------------
// The __config__ file is mounted on each service on the filesystem's root.
message Configuration{
    message SlotSpec {
        int32 port = 1;
        ProtocolMesh transport_protocol = 2;
    }
    Instance gateway = 1;
    map<string, string> enviroment_variables = 2;
    repeated SlotSpec slot = 3; // Only some of the specified ports and the protocol submesh for each slot.

    // Un servicio puede solicitar instancias de servicios con un ledger o un tensor aunque este no los ofrezca, y por tanto no aparezcan estos en su especificacion.
    // Pero para los tensores y ledgers que si se especifican en la descripcion del servicio se puede concluir que van a ser requeridas instancias de los mismos al nodo,
    // por lo tanto, el nodo tiene la opcion de añadir estas instancias de manera opcional en la configuracion de arranque del servicio.
    repeated Instance tensor_instances = 4;
    repeated Instance ledger_instances = 5;
}