syntax = "proto3";
package ipss;

//  -----------------------
//  DEFINITIONS.
//  -----------------------
message PrimitiveDef {
    repeated string tag = 1; // INT32, ...
    optional string regex = 2; // {0-10}, ...
    // Primitive specification can be applied. <- must be optional
}

message FieldDef {
    oneof value{
        MessageDef message = 1;
        PrimitiveDef primitive = 2;
    }
}

message ParamDef {
    repeated string tag = 1;
    FieldDef field = 2;
    bool repeated = 3;
    bool optional = 4;
}

message MessageDef {
    repeated string tag = 1;
    map<int32, ParamDef> field = 2;
}

message MethodDef {
    repeated string tag = 1;
    MessageDef input_message = 2;
    bool is_input_stream = 3;
    MessageDef output_message = 4;
    bool is_output_stream = 5;
}

message ApplicationDef {
    repeated string tag = 1;
    map<int32, MethodDef> method = 2; // Exemple of method call: 8080.1()
}

message Any {
    optional FieldDef field = 1;
    bytes value = 2;
}


//  -----------------------
//  SERVICE SPECIFICATION.
//  -----------------------
// Hash Table ( IPDL ?)
message Hash {
    string hash = 1; // d5tr ...
    repeated string tag = 2; // SHA256 ...
    // Mesh specification can be applied. <- must be optional
}

// API: Defines how you can interact with the service, the ports where it listens, the communication protocols that it supports, methods and the different errors and responses that it can give.
message ProtocolMesh {
    repeated string tag = 1;
    // Mesh specification can be applied. <- must be optional
}

message Slot {
    int32 port = 1;
    ProtocolMesh transport_protocol = 2;
    ApplicationDef application_protocol = 3;
    // Cost function can be applied. <- must be optional
}

// Container: Specifies the container where the service runs, microarchitecture, entry point and filesystem (DAG?), and environment variables.
message Architecture {
    repeated string tag = 1;
    // Architecture specification can be applied. <- must be optional.
}

message Container {
    Architecture architecture = 1;
    repeated Hash filesystem = 2;
    map<string, FieldDef> enviroment_variables = 3;
    string entrypoint = 4;
}

// Tensor: Defines the “intelligence” that the service can provide, I think it would be a description of a polynomial (without coefficients and describing the variables).
message Tensor {
    message Variable {
        string id = 1;
        repeated string tag = 2;
        optional FieldDef field = 3;
    }
    repeated Variable output_variable = 1;
    repeated Variable input_variable = 2;
}

// Ledger: Defines the database that the service can provide.
message Ledger {
    repeated string tag = 1;
    // Ledger specification can be applied. <- must be optional
    //  it would be a class diagram and a consensus algorithm.
}

message Service {
    MessageDef syntax = 1;
    Container container = 2;
    repeated Slot api = 3;
    Tensor tensor = 4;
    Ledger ledger = 5;
}


//  ------------------------
//  INSTANCE SPECIFICATION.
//  ------------------------
// Used for specify node peers, node-host instancies, ledger-nodes instancies and tensor instancies.
message Instance {
    message Uri {
        string ip = 1;
        int32 port = 2;
    }
    repeated Slot api = 1;
    map<int32, Uri> uri_slot = 2; // map like [ 8080 -> 192.17.0.4:6899, ]
}

//  -------------------------------
//  SERVICE INITIAL CONFIGURATION.
//  -------------------------------
// The __config__ file is mounted on each service on the filesystem's root.
message Configuration {
    map<string, Any> enviroment_variables = 1;
    map<int32, ProtocolMesh> spec_slot = 2; // Only some of the specified ports and a protocol-submesh subgroup of the protocol-submesh of each slot.    
}

message ConfigurationFile{
    Instance gateway = 1;
    Configuration config = 2;
    // Un servicio puede solicitar instancias de servicios con un ledger o un tensor aunque este no los ofrezca, y por tanto no aparezcan estos en su especificacion.
    // Pero para los tensores y ledgers que si se especifican en la descripcion del servicio se puede concluir que van a ser requeridas instancias de los mismos al nodo,
    // por lo tanto, el nodo tiene la opcion de añadir estas instancias de manera opcional en la configuracion de arranque del servicio.
    repeated Instance tensor_instances = 3;
    repeated Instance ledger_instances = 4;
}